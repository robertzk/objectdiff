% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/patch.R
\name{patch}
\alias{as.patch}
\alias{atomic_differences_patch}
\alias{attributes_patch}
\alias{differences_patch}
\alias{identity_patch}
\alias{patch}
\alias{trivial_patch}
\title{patch}
\usage{
as.patch(x)

identity_patch()

trivial_patch(object)

atomic_differences_patch(old_object, new_object, transition = TRUE)

differences_patch(old_object, new_object, differences)

attributes_patch(old_object, new_object)
}
\arguments{
\item{x}{function. Apply \code{patch} class.}

\item{object}{ANY. An R object that will be returned by the
function created from \code{trivial_patch}. This is equivalent to
"create a function that does nothing except return this object".}

\item{old_object}{atomic.}

\item{new_object}{atomic.}

\item{transition}{logical. Whether or not to use a transition depending
on how many element do not match. Namely, if over 50% do not match in
from a random sample of 100 elements (so most of \code{new_object} is
probably different than \code{old_object}) then replace it completely
with a trivial patch; otherwise, perform a more subtle calculation
using \code{base::!=} and stores only exactly which elements changed.}

\item{differences}{logical or integer. The differences in first and second object.
These should be calculated externally because a different approach
could be used for different objects (e.g., lists versus atomic;
in the former we would need \code{base::identical} on each element,
whereas in the latter we could use \code{base::`!=`}).}
}
\description{
Patching related methods.

Generate a patch for two atomic objects that are close in values.

This patch will use another patch to record changes to attributes
(if any). Otherwise, given indices of changed object, it will 
generate a patch over those indices.

Assume two objects are identical and only patch their attributes.
}
\examples{
x <- 1:10; y <- x; y[1] <- 5
patch <- objectdiff:::atomic_differences_patch(x, y) 
stopifnot(identical(y, patch(x)))
}

